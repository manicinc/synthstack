name: CI/CD Pipeline

on:
  push:
    branches: [ "main", "master", "develop" ]
  pull_request:
    branches: [ "main", "master", "develop" ]

env:
  NODE_VERSION: '20'
  PNPM_VERSION: '9'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # =========================================
  # Code Quality & Testing
  # =========================================
  test:
    name: Test & Lint
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install pnpm
      uses: pnpm/action-setup@v3
      with:
        version: ${{ env.PNPM_VERSION }}
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'pnpm'
        
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
      
    - name: Run Linting
      run: pnpm lint
      
    - name: Run Type Checking
      run: pnpm typecheck
      
    - name: Run Unit Tests
      run: pnpm test
      
    - name: Upload Test Coverage
      uses: codecov/codecov-action@v4
      if: always()
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        fail_ci_if_error: false

  # =========================================
  # E2E Tests
  # =========================================
  e2e-test:
    name: E2E Tests
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install pnpm
      uses: pnpm/action-setup@v3
      with:
        version: ${{ env.PNPM_VERSION }}
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'pnpm'
        
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
      
    - name: Install Playwright Browsers
      run: pnpm --filter @synthstack/web exec playwright install --with-deps chromium

    - name: Setup environment
      run: cp apps/web/.env.example apps/web/.env

    - name: Run E2E Tests
      run: pnpm --filter @synthstack/web test:e2e --project=chromium
      env:
        PLAYWRIGHT_BASE_URL: http://localhost:3050
        # Vite environment variables for E2E tests
        VITE_API_URL: http://localhost:3003
        VITE_SUPABASE_URL: ""
        VITE_SUPABASE_ANON_KEY: ""
        
    - name: Upload E2E Test Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: e2e-test-results
        path: |
          apps/web/test-results/
          apps/web/playwright-report/
        retention-days: 7

  # =========================================
  # Build Frontend
  # =========================================
  build-web:
    name: Build Web App
    runs-on: ubuntu-latest
    needs: test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Install pnpm
      uses: pnpm/action-setup@v3
      with:
        version: ${{ env.PNPM_VERSION }}
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'pnpm'
        
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
      
    - name: Build Web Application
      run: pnpm --filter @synthstack/web build
      env:
        VITE_API_URL: ${{ vars.VITE_API_URL }}
        VITE_SUPABASE_URL: ${{ vars.VITE_SUPABASE_URL }}
        VITE_SUPABASE_ANON_KEY: ${{ secrets.VITE_SUPABASE_ANON_KEY }}
        VITE_STRIPE_PUBLISHABLE_KEY: ${{ vars.VITE_STRIPE_PUBLISHABLE_KEY }}
      
    - name: Upload Web Build Artifact
      uses: actions/upload-artifact@v4
      with:
        name: web-dist
        path: apps/web/dist/spa
        retention-days: 7

  # =========================================
  # Build Docker Images
  # =========================================
  build-api:
    name: Build API Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')

    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install pnpm
      uses: pnpm/action-setup@v3
      with:
        version: ${{ env.PNPM_VERSION }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'pnpm'

    - name: Install dependencies
      run: pnpm install --frozen-lockfile

    - name: Build workspace dependencies and API Gateway
      run: |
        pnpm --filter @synthstack/types build
        pnpm --filter @synthstack/referrals-credits build
        pnpm --filter @synthstack/api-gateway build

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/api
        tags: |
          type=sha,prefix=
          type=ref,event=branch
          type=raw,value=latest,enable={{is_default_branch}}

    - name: Build and push API image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./packages/api-gateway/Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  build-ml:
    name: Build ML Service Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    permissions:
      contents: read
      packages: write
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/ml-service
        tags: |
          type=sha,prefix=
          type=ref,event=branch
          type=raw,value=latest,enable={{is_default_branch}}
          
    - name: Build and push ML image
      uses: docker/build-push-action@v5
      with:
        context: ./packages/ml-service
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # =========================================
  # Deploy to Staging
  # =========================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-web, build-api, build-ml]
    if: github.event_name == 'push' && github.ref == 'refs/heads/develop'
    environment: staging

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download Web Build
      uses: actions/download-artifact@v4
      with:
        name: web-dist
        path: ./dist

    - name: Setup SSH Key
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        echo "${{ secrets.REMOTE_SSH_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        
        # Add server to known_hosts
        for i in 1 2 3; do
          ssh-keyscan -H ${{ secrets.REMOTE_HOST_STAGING }} >> ~/.ssh/known_hosts 2>/dev/null && break
          sleep 2
        done
        chmod 644 ~/.ssh/known_hosts
        
        # Configure SSH
        cat >> ~/.ssh/config << EOF
        Host staging
          HostName ${{ secrets.REMOTE_HOST_STAGING }}
          User ${{ secrets.REMOTE_USER }}
          IdentityFile ~/.ssh/deploy_key
          IdentitiesOnly yes
          StrictHostKeyChecking accept-new
          BatchMode yes
        EOF
        chmod 600 ~/.ssh/config

    - name: Test SSH Connection
      run: |
        echo "Testing SSH connection to staging..."
        ssh -o ConnectTimeout=10 staging "echo 'SSH connection successful!'"

    - name: Deploy Web to Staging
      run: |
        rsync -avz --delete -e "ssh -i ~/.ssh/deploy_key" ./dist/ ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST_STAGING }}:/var/www/synthstack-staging/

    - name: Login to Container Registry on Server
      env:
        GH_TOKEN: ${{ secrets.GH_PAT }}
      run: |
        # Server needs permission to pull Docker images from GitHub
        ssh staging "echo '${GH_TOKEN}' | docker login ghcr.io -u manicinc --password-stdin"

    - name: Deploy Services to Staging
      run: |
        ssh staging 'cd /opt/synthstack-staging && \
          docker compose down --remove-orphans || true && \
          docker rm -f $(docker ps -aq) 2>/dev/null || true && \
          docker compose pull && \
          docker compose up -d --force-recreate --remove-orphans && \
          docker system prune -f'

    - name: Verify Deployment
      run: |
        sleep 10
        curl -f https://staging.synthstack.app/health || echo "Warning: Health check failed"
        
    # TODO: Configure Slack webhook to enable notifications
    # - name: Notify Slack on Success
    #   if: success()
    #   uses: slackapi/slack-github-action@v1.25.0
    #   with:
    #     payload: |
    #       {
    #         "text": "‚úÖ Staging deployment successful",
    #         "blocks": [
    #           {
    #             "type": "section",
    #             "text": {
    #               "type": "mrkdwn",
    #               "text": "‚úÖ *Staging Deployment Successful*\n<https://staging.synthstack.app|View Staging>"
    #             }
    #           }
    #         ]
    #       }
    #   env:
    #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # =========================================
  # Deploy to Production
  # =========================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-web, build-api, build-ml]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    environment: production

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download Web Build
      uses: actions/download-artifact@v4
      with:
        name: web-dist
        path: ./dist

    - name: Setup SSH Key
      run: |
        mkdir -p ~/.ssh
        chmod 700 ~/.ssh
        echo "${{ secrets.REMOTE_SSH_KEY }}" > ~/.ssh/deploy_key
        chmod 600 ~/.ssh/deploy_key
        
        # Add server to known_hosts (retry a few times for reliability)
        for i in 1 2 3; do
          ssh-keyscan -H ${{ secrets.REMOTE_HOST_PRODUCTION }} >> ~/.ssh/known_hosts 2>/dev/null && break
          sleep 2
        done
        chmod 644 ~/.ssh/known_hosts
        
        # Configure SSH to use our key
        cat >> ~/.ssh/config << EOF
        Host production
          HostName ${{ secrets.REMOTE_HOST_PRODUCTION }}
          User ${{ secrets.REMOTE_USER }}
          IdentityFile ~/.ssh/deploy_key
          IdentitiesOnly yes
          StrictHostKeyChecking accept-new
          BatchMode yes
        EOF
        chmod 600 ~/.ssh/config

    - name: Test SSH Connection
      run: |
        echo "Testing SSH connection to ${{ secrets.REMOTE_HOST_PRODUCTION }}..."
        ssh -o ConnectTimeout=10 production "echo 'SSH connection successful!'"

    - name: Create Backup
      run: |
        ssh production 'cd /opt/synthstack && if [ -f ./scripts/backup.sh ]; then ./scripts/backup.sh; else echo "No backup script found, skipping..."; fi'

    - name: Deploy Web to Production
      run: |
        rsync -avz --delete -e "ssh -i ~/.ssh/deploy_key" ./dist/ ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST_PRODUCTION }}:/var/www/synthstack/

    - name: Copy Deploy Configuration
      run: |
        ssh production 'mkdir -p /opt/synthstack/deploy'
        rsync -avz -e "ssh -i ~/.ssh/deploy_key" ./deploy/ ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST_PRODUCTION }}:/opt/synthstack/deploy/

    - name: Verify Environment File Exists
      run: |
        ssh production 'test -f /opt/synthstack/deploy/.env || (echo "ERROR: /opt/synthstack/deploy/.env not found. Create it manually on the server." && exit 1)'

    - name: Login to Container Registry on Server
      env:
        GH_TOKEN: ${{ secrets.GH_PAT }}
      run: |
        # Server needs permission to pull Docker images from GitHub
        ssh production "echo '${GH_TOKEN}' | docker login ghcr.io -u manicinc --password-stdin"

    - name: Deploy Services to Production
      run: |
        ssh production 'cd /opt/synthstack && \
          docker compose -f deploy/docker-compose.yml down --remove-orphans || true && \
          docker rm -f $(docker ps -aq) 2>/dev/null || true && \
          docker compose -f deploy/docker-compose.yml pull && \
          docker compose -f deploy/docker-compose.yml up -d --force-recreate --remove-orphans && \
          docker system prune -f'

    - name: Run Database Migrations
      run: |
        ssh production 'cd /opt/synthstack && docker compose -f deploy/docker-compose.yml exec -T api pnpm db:migrate || echo "Migration skipped or no migrations to run"'

    - name: Verify Deployment
      run: |
        echo "Waiting for services to stabilize..."
        sleep 15

        echo "Checking frontend health..."
        if curl -sf https://synthstack.app/health; then
          echo "‚úÖ Frontend is healthy"
        else
          echo "‚ö†Ô∏è Warning: Frontend health check failed"
        fi

        echo "Checking API health..."
        if curl -sf https://api.synthstack.app/health; then
          echo "‚úÖ API is healthy"
        else
          echo "‚ö†Ô∏è Warning: API health check failed"
          echo "   The generate-api-docs job may fail if API is not healthy"
        fi
        
    - name: Purge CDN Cache
      if: success()
      continue-on-error: true
      run: |
        if [ -n "${{ secrets.CLOUDFLARE_ZONE_ID }}" ] && [ -n "${{ secrets.CLOUDFLARE_API_TOKEN }}" ]; then
          curl -X POST "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/purge_cache" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data '{"purge_everything":true}'
        else
          echo "Cloudflare credentials not configured, skipping cache purge"
        fi
          
    # TODO: Configure Slack webhook to enable notifications
    # - name: Notify Slack on Success
    #   if: success()
    #   uses: slackapi/slack-github-action@v1.25.0
    #   with:
    #     payload: |
    #       {
    #         "text": "üöÄ Production deployment successful",
    #         "blocks": [
    #           {
    #             "type": "section",
    #             "text": {
    #               "type": "mrkdwn",
    #               "text": "üöÄ *Production Deployment Successful*\nCommit: `${{ github.sha }}`\n<https://synthstack.app|View Production>"
    #             }
    #           }
    #         ]
    #       }
    #   env:
    #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
    #
    # - name: Notify Slack on Failure
    #   if: failure()
    #   uses: slackapi/slack-github-action@v1.25.0
    #   with:
    #     payload: |
    #       {
    #         "text": "‚ùå Production deployment failed",
    #         "blocks": [
    #           {
    #             "type": "section",
    #             "text": {
    #               "type": "mrkdwn",
    #               "text": "‚ùå *Production Deployment Failed*\nCommit: `${{ github.sha }}`\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Logs>"
    #             }
    #           }
    #         ]
    #       }
    #   env:
    #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # =========================================
  # Generate API Documentation
  # =========================================
  # Fetches OpenAPI spec from production API after deployment
  generate-api-docs:
    name: Generate API Docs
    runs-on: ubuntu-latest
    needs: deploy-production
    if: success()
    continue-on-error: true  # Don't block CI if API docs generation fails

    permissions:
      contents: write
      pages: write
      id-token: write
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install pnpm
      uses: pnpm/action-setup@v3
      with:
        version: ${{ env.PNPM_VERSION }}
        
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'pnpm'
        
    - name: Install dependencies
      run: pnpm install --frozen-lockfile
      
    - name: Wait for production API and fetch OpenAPI spec
      id: fetch-openapi
      run: |
        mkdir -p packages/api-gateway/docs packages/api-gateway/sdk
        API_URL="https://api.synthstack.app"
        
        echo "‚è≥ Waiting for production API to be ready..."
        echo "   This may take a few minutes after deployment..."
        
        MAX_ATTEMPTS=60
        SLEEP_TIME=5
        
        for i in $(seq 1 $MAX_ATTEMPTS); do
          echo "Attempt $i/$MAX_ATTEMPTS: Checking $API_URL/health..."
          
          HEALTH=$(curl -sf --connect-timeout 10 "$API_URL/health" 2>/dev/null || echo "")
          
          if echo "$HEALTH" | grep -q '"status":"ok"'; then
            echo "‚úÖ API is healthy!"
            echo ""
            echo "üìö Fetching OpenAPI spec..."
            
            if curl -sf --connect-timeout 30 "$API_URL/openapi.json" -o packages/api-gateway/docs/openapi.json; then
              echo "‚úÖ OpenAPI spec saved!"
              echo "has_spec=true" >> $GITHUB_OUTPUT
              exit 0
            else
              echo "‚ö†Ô∏è API is healthy but /openapi.json returned error"
              echo "   Make sure your API exposes GET /openapi.json"
            fi
          fi
          
          if [ $i -eq $MAX_ATTEMPTS ]; then
            echo ""
            echo "‚ùå API did not become healthy after $((MAX_ATTEMPTS * SLEEP_TIME)) seconds"
            echo "   Check your deployment logs"
            echo "has_spec=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "   Not ready yet, waiting ${SLEEP_TIME}s..."
          sleep $SLEEP_TIME
        done

    - name: Generate TypeScript SDK
      if: steps.fetch-openapi.outputs.has_spec == 'true'
      run: |
        npx openapi-typescript packages/api-gateway/docs/openapi.json -o packages/api-gateway/sdk/api.d.ts
        
    - name: Build ReDoc static site
      if: steps.fetch-openapi.outputs.has_spec == 'true'
      run: |
        npx @redocly/cli build-docs packages/api-gateway/docs/openapi.json -o packages/api-gateway/docs/index.html
        
    - name: Upload API Docs artifact
      if: steps.fetch-openapi.outputs.has_spec == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: api-docs
        path: |
          packages/api-gateway/docs/
          packages/api-gateway/sdk/
        retention-days: 30
        
    - name: Deploy to GitHub Pages
      if: steps.fetch-openapi.outputs.has_spec == 'true'
      uses: peaceiris/actions-gh-pages@v4
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./packages/api-gateway/docs
        destination_dir: api-docs
        
    - name: Commit SDK updates
      if: steps.fetch-openapi.outputs.has_spec == 'true'
      uses: stefanzweifel/git-auto-commit-action@v5
      with:
        commit_message: 'docs: update OpenAPI spec and TypeScript SDK [skip ci]'
        file_pattern: 'packages/api-gateway/docs/* packages/api-gateway/sdk/*'
        commit_user_name: github-actions[bot]
        commit_user_email: github-actions[bot]@users.noreply.github.com

  # =========================================
  # Post-Deployment Tasks
  # =========================================
  post-deploy:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: deploy-production
    if: success()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Trigger Search Engine Indexing
      continue-on-error: true
      run: |
        # Ping Google
        curl -s "https://www.google.com/ping?sitemap=https://synthstack.app/sitemap.xml" || true
        # Ping Bing
        curl -s "https://www.bing.com/ping?sitemap=https://synthstack.app/sitemap.xml" || true
        
    # Sitemap is generated at build time via apps/web/scripts/generate-sitemap.ts
    # No runtime regeneration needed
          
    - name: Run Lighthouse Audit
      continue-on-error: true
      uses: treosh/lighthouse-ci-action@v11
      with:
        urls: |
          https://synthstack.app
          https://synthstack.app/features
          https://synthstack.app/pricing
        uploadArtifacts: true
        temporaryPublicStorage: true
